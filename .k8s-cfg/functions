#!/bin/bash
# rename=0 # override in mycfg if renaming the components.
# set -o errexit
set -o nounset
set -o pipefail
# The next incarnation will use a git repo pulled into the
# jenkins home

# volumes mapped from git repo

# These scripts assume a directory structure on the target of
# under the jenkins home of 
# .../
#         /.k8s-cfg    # secrets [ until we get k8s secrets + vault ]
#         /bin     # kubectl or other binaries
#         /k8s     # yaml configs
#         /scripts # this script and collections of other helpers
function check
{
    if [[ ! ${dir:-} ]]; then
        echo "dir: variable not set"
        echo "A recipe in the script sourcing this file may work:"
        echo "dir=\$(readlink -f \$(dirname \$(readlink -f \${0}))/..)"
        exit 3
    fi
}

check

export cfgdir=${dir}/.cfg
export k8scfgdir=$(readlink -f ${dir}/.k8s-cfg)
export k8scfgbin=$(readlink -f ${k8scfgdir}/../bin)

mkdir -p ${k8scfgdir}  ${dir}/.private
chmod 700 ${dir} ${k8scfgdir} ${dir}/.private ${cfgdir}

if [[ ! -e ${k8scfgdir}/kubecfg ]]; then
    echo "Unconfigured options in one of [.k8s-cfg/{kubecfg,options}]"
    exit 3
fi

. ${k8scfgdir}/kubecfg
# set default manipulation # inject secret like rsa pub key
. ${k8scfgdir}/make-yaml

if [[ -e ${make_yaml_file} || -L ${make_yaml_file} ]]; then
    . ${make_yaml_file}
else
    cat <<EOF

Required function make-yaml is not defined It's simplest form could be
cat of the yaml file.

Any function that dumps the yaml on stdout, such as a sed stream edit
may also be used.

override the default with options in .cfg/make-yaml, or 

  ln -s ../.k8s-cfg/make-yaml .cfg/make-yaml

EOF
    exit 3
fi

function start
{
    kubectl create -f- <<EOF
$(make-yaml)
EOF
}

function stop
{
    kubectl delete -f- <<EOF
$(make-yaml)
EOF
}

function status-all
{
    kubectl get --output=wide node
    kubectl get --all-namespaces --output=wide rc,pods,svc,ep
}

function status
{
    if (( rename )); then
        local name=${id}${name}
    fi
    kubectl get --output=wide node
    echo replication controllers
    kubectl get --output=wide rc         ${name}             --namespace=${namespace}
    echo pods
    kubectl get --output=wide po                             --namespace=${namespace}|head -1
    kubectl get --output=wide po                             --namespace=${namespace}|grep ${name}
    echo services
    kubectl get --output=wide svc        ${name}             --namespace=${namespace}
    echo endpoints
    kubectl get --output=wide ep         ${name}             --namespace=${namespace}
    echo secrets
    kubectl get --output=wide secret     ${name}-secret      --namespace=${namespace}
}

# --namespace=kube-system exec -it k8s-jenkins-ui-qfduo -c k8s-jump -- /bin/bash

function generate
{
    rm -f ${yaml}
    if (( debug )); then
        echo "building yaml file ${yaml} for debugging"
        if [[ ! -e ${yaml} ]]; then
            make-yaml > ${yaml}
        fi
        chmod 600 ${yaml}
    fi
}

function git-config
{
    repo=${dir##*/}
    if (( ! rename )) ; then
        local id=""
    fi
    host=${id}k8s-git-repo

    echo
    if [[ -e ${dir}/.git/config ]] && grep remote ${dir}/.git/config ; then
        echo
        echo "git repo initialization if your prior repo didn't work"
        echo
        cat <<EOF
        ssh ${host}<<INIT
mkdir ${repo}.git
cd ${repo}.git
git init --bare
INIT
EOF
        echo There is an existing git config and repo tag.
        echo Remove the remotes or modify them manually.
        echo
        cat <<MSG
# id comes from .k8s-cfg/config
host ${id}k8s-git-repo
  User                  git
#  Port                  2222
# the name I have the k8s service. . .
#  Hostname             alternate-name
  IdentitiesOnly        yes
  TCPKeepAlive          yes
  IdentityFile          ~/.ssh/id_ed25519
# If connecting from non local work laptop for example . . .
#  ProxyCommand       ssh -XC -A k8s-master-01 -W '%h:%p'
MSG
        echo
        echo "#############################################"
        usage
        exit 3
    fi

    # .ssh/config entry to enable simple access

    # Change port to 22 and comment hostname if using k8s yaml definition.
    # and adding the master [ or host like k8s-master-01 ] to /etc/hosts
    # If accessing remotely via a docker host, maybe mapping -p 2222:22
    # . . .

    # You probably want to have either DNS access or /etc/hosts configured
    # for your host and jump host name. In this example k8s-master-01 acts
    # as the jump host to the DNS enabled k8s cluster

    ssh ${host}<<INIT
mkdir ${repo}.git
cd ${repo}.git
git init --bare
INIT

    cat <<EOF
git remote add ${repo} ${k8srepo}
git push --set-upstream ${repo} master
EOF
    git remote add ${repo} ${k8srepo}
    git push --set-upstream ${repo} master
    git push ${repo} master

    git remote add github ${hubrepo}
    git push --set-upstream github master
}

function describe
{
    local namespace=$(make-yaml ${inyaml}|grep namespace:|grep -v '^ *#'|tail -1|cut -f 2 -d :)
    namespace=${namespace// /}
    if (( rename )) ; then
        local name=${id}${name}
    fi
    if [[ ${namespace:-} ]]; then
        kubectl describe --namespace=${namespace} po ${name}
    else
        kubectl describe po ${name}
    fi
}

function replicas
{
    if (( rename )); then
        local name=${id}${name}
    fi
    kubectl scale --replicas=${1} rc/${name} --namespace=${name}
}

function push-image
{
    local image=${dir##*/}
    docker save ${image} > ${image}.tar
    for host in k8s-${id}master-01 k8s-${id}node-0{1..2}; do
        echo pushing to host ${host}
        ssh ${host} mkdir -p work
        rsync -rlaz --progress --partial ${dir}/${image}.tar ${host}:work/
        ssh -tt ${host} "for file in work/${image}.tar; do echo sudo docker load -i \${file}; sudo docker load -i \${file}; done"
    done
}

function main
{
    if (( $# )) ; then
        # set flags prior to calling any methods
        for arg in ${@}; do
            case ${arg} in
                --debug)
                    debug=1
                    ;;
                --rename)
                    rename=1
                    ;;
                --rename=*)
                    rename=${arg##*=}
                    if (( ${#rename} != 0 )); then
                        rename=1
                    fi
                    ;;
                --verbose)
                    verbose=1
                    ;;
            esac
        done
        generate
        for arg in ${@}; do
            case ${arg} in
                --debug|--verbose) # ignore these, don't generate a usage call
                    ;;
                --describe)
                    describe
                    ;;
                --push-image)
                    push-image
                    ;;
                --start)
                    start
                    ;;
                --stop)
                    stop
                    ;;
                --status)
                    status
                    ;;
                --status-all)
                    status-all
                    ;;
                --git-config)
                    git-config
                    ;;
                --tunnel-start)
                    tunnel-start
                    ;;
                --tunnel-stop)
                    tunnel-stop
                    ;;
                --tunnel-status)
                    tunnel-status
                    ;;
                --replicas=[0-9]*)
                    c=${arg##*=}
                    replicas ${c}
                    ;;
                --replicas)
                    printf "\n${0##*/} --replicas requires an number of replicas to scale\n"
                    usage
                    ;;
                *)
                    usage
            esac
        done
    else
        usage
    fi
#    exit
}

if [[ -e ${k8scfgdir}/usage ]]; then
    . ${k8scfgdir}/usage
fi

if [[ -e ${cfgdir}/usage ]]; then
    . ${cfgdir}/usage
fi

if [[ -e ${k8scfgdir}/tunnel ]]; then
    . ${k8scfgdir}/tunnel
fi

export namespace=$(namespace)

if [[ -e ${cfgdir}/overrides ]]; then
    . ${cfgdir}/overrides
fi

