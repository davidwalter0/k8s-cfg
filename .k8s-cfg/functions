#!/bin/bash
set -o errexit
set -o nounset
set -o pipefail
# These scripts assume a directory structure on the target of
# under the jenkins home of 
# .../
#         /.k8s-cfg    # generated secrets and configure items with text replacement.
#         /bin     # kubectl or other binaries
#         /k8s     # yaml configs
#         /scripts # this script and collections of other helpers

function init
{
    local cfgdir=${dir}/.cfg
    local mycfg=${cfgdir}/mycfg

    if [[ ! -e ${mycfg:-} ]]; then
        echo "${mycfg} was not found. have you tailored the configuration to your requirements?"
        exit 3
    fi
    . ${mycfg}
}

function wrap-command
{
    local cfgdir=${dir}/.cfg
    local k8scfgdir=$(readlink -f ${dir}/.k8s-cfg)
    . ${k8scfgdir}/init
   # . ${k8scfgdir}/flags
   # . ${k8scfgdir}/mycfg
   # eval ${@}
    eval ${@}
}

function check
{
    export cfgdir=${dir}/.cfg
    export k8scfgdir=$(readlink -f ${dir}/.k8s-cfg)
    export k8scfgbin=$(readlink -f ${k8scfgdir}/../bin)
    if [[ ! ${dir:-} ]]; then
        echo "dir: variable not set"
        echo "A recipe in the script sourcing this file may work:"
        echo "dir=\$(readlink -f \$(dirname \$(readlink -f \${0}))/..)"
        exit 3
    fi
}

function start
{
    local k8scfgdir=${dir}/.k8s-cfg
    . ${k8scfgdir}/init
    . ${k8scfgdir}/flags
    kubectl create -f- <<EOF
$(make-yaml)
EOF
}

function stop
{
    local k8scfgdir=${dir}/.k8s-cfg
    . ${k8scfgdir}/init
    . ${k8scfgdir}/flags
    kubectl delete -f- <<EOF
$(make-yaml)
EOF
}

function status-all
{
    local k8scfgdir=${dir}/.k8s-cfg
    . ${k8scfgdir}/init
    kubectl get --output=wide node
    kubectl get --all-namespaces --output=wide rc,pods,svc,ep
}

function status
{
    local k8scfgdir=${dir}/.k8s-cfg
    local cfgdir=${dir}/.cfg
    . ${k8scfgdir}/init
    echo nodes
    namespace-command kubectl get --output=wide node
    echo replication controllers
    namespace-command kubectl get --output=wide rc         ${name}        
    echo pods
    namespace-command kubectl get --output=wide po                        |head -1
    namespace-command kubectl get --output=wide po                        |grep ${name}
    echo services
    namespace-command kubectl get --output=wide svc        ${name}        
    echo endpoints
    namespace-command kubectl get --output=wide ep         ${name}        
    echo secrets
    namespace-command kubectl get --output=wide secret     ${name}-secret 
}

# --namespace=kube-system exec -it k8s-jenkins-ui-qfduo -c k8s-jump -- /bin/bash

function generate
{
    local k8scfgdir=${dir}/.k8s-cfg
    local cfgdir=${dir}/.cfg
    . ${k8scfgdir}/init
    # . ${k8scfgdir}/flags
    # . ${cfgdir}/mycfg

    rm -f ${yaml}
    if (( debug )); then
        echo "building yaml file ${yaml} for debugging"
        if [[ ! -e ${yaml} ]]; then
            (make-yaml > ${yaml} )
        fi
        chmod 600 ${yaml}
    fi
}

function git-config
{
    local k8scfgdir=${dir}/.k8s-cfg
    . ${k8scfgdir}/init
    . ${k8scfgdir}/flags

    local repo=${dir##*/}
    local host=${id}k8s-git-repo

    echo
    if [[ -e ${dir}/.git/config ]] && grep remote ${dir}/.git/config ; then
        echo
        echo "git repo initialization if your prior repo didn't work"
        echo
        cat <<EOF
        ssh ${host}<<INIT
mkdir ${repo}.git
cd ${repo}.git
git init --bare
INIT
EOF
        echo There is an existing git config and repo tag.
        echo Remove the remotes or modify them manually.
        echo
        cat <<MSG
# id comes from .k8s-cfg/config
host ${id}k8s-git-repo
  User                  git
#  Port                  2222
# the name I have the k8s service. . .
#  Hostname             alternate-name
  IdentitiesOnly        yes
  TCPKeepAlive          yes
  IdentityFile          ~/.ssh/id_ed25519
# If connecting from non local work laptop for example . . .
#  ProxyCommand       ssh -XC -A k8s-master-01 -W '%h:%p'
MSG
        echo
        echo "#############################################"
cat <<EOF
You can manually fix up your config using options similar to:

    git remote add ${repo} ${k8srepo}
    git push --set-upstream ${repo} master
    git config push.default simple
    git push ${repo} master

    git remote add github ${hubrepo}
    git push --set-upstream github master

EOF
        usage
        exit 3
    fi

    # .ssh/config entry to enable simple access

    # Change port to 22 and comment hostname if using k8s yaml definition.
    # and adding the master [ or host like k8s-master-01 ] to /etc/hosts
    # If accessing remotely via a docker host, maybe mapping -p 2222:22
    # . . .

    # You probably want to have either DNS access or /etc/hosts configured
    # for your host and jump host name. In this example k8s-master-01 acts
    # as the jump host to the DNS enabled k8s cluster

    ssh ${host}<<INIT
mkdir ${repo}.git
cd ${repo}.git
git init --bare
INIT

    cat <<EOF
git remote add ${repo} ${k8srepo}
git push --set-upstream ${repo} master
EOF
    git remote add ${repo} ${k8srepo}
    git push --set-upstream ${repo} master
    git config push.default simple
    git push ${repo} master

    git remote add github ${hubrepo}
    git push --set-upstream github master
}

function namespace-command
{
    local k8scfgdir=${dir}/.k8s-cfg
    local cfgdir=${dir}/.cfg
    . ${k8scfgdir}/init
    # . ${k8scfgdir}/flags
    # . ${k8scfgdir}/kubecfg
    # . ${cfgdir}/mycfg

#    local namespace=$(namespace)
    if [[ ! ${namespace:-} ]]; then
        namespace=default
    fi
    local command="${@} --namespace=${namespace}"
    if (( debug )) ; then
        echo ${command}
    fi
    ${command}
}

function describe
{
    namespace-command kubectl describe po ${name}
}

function replicas
{
    namespace-command kubectl scale --replicas=${1} rc/${name}
}

function push-image
{
    local k8scfgdir=${dir}/.k8s-cfg
    . ${k8scfgdir}/init

    local image=${dir##*/}
    docker save ${image} > ${image}.tar
    for host in k8s-${id}master-01 k8s-${id}node-0{1..2}; do
        echo pushing to host ${host}
        ssh ${host} mkdir -p work
        rsync -rlaz --progress --partial ${dir}/${image}.tar ${host}:work/
        ssh -tt ${host} "for file in work/${image}.tar; do echo sudo docker load -i \${file}; sudo docker load -i \${file}; done"
    done
}

function main
{
    local k8scfgdir=${dir}/.k8s-cfg
    local cfgdir=${dir}/.cfg
    # local k8scfgdir=${dir}/.k8s-cfg
    # local flags=${k8scfgdir}/flags
    # local init=${k8scfgdir}/init
    # . ${k8scfgdir}/init
    # . ${init}
    # . ${flags}
    # mkdir -p ${k8scfgdir}  ${dir}/.private
    # chmod 700 ${dir} ${k8scfgdir} ${dir}/.private ${cfgdir}
    local command=""
    local count=""
    if [[ -e ${cfgdir}/usage ]]; then
        . ${cfgdir}/usage
    else
        . ${k8scfgdir}/usage
    fi

    if (( $# )) ; then
        for arg in ${@}; do
            case ${arg} in
                --debug|--verbose|--name=*|--namespace=*) # ignore these, don't generate a usage call
                    ;;
                --name|--namespace) # ignore these, don't generate a usage call
                    echo "--name and --namespace require arguments --name=..."
                    usage
                    exit 3
                    ;;
                --replicas=[0-9]*)
                    count=${arg##*=}
                    command="replicas ${count}"
                    ;;
                --replicas)
                    printf "\n${0##*/} --replicas requires an number of replicas to scale\n"
                    usage
                    exit 3
                    ;;
                --describe)
                    command=describe
                    ;;
                --push-image)
                    command=push-image
                    ;;
                --start)
                    command=start
                    ;;
                --stop)
                    command=stop
                    ;;
                --status)
                    command=status
                    ;;
                --status-all)
                    command=status-all
                    ;;
                --git-config)
                    command=git-config
                    ;;
                --tunnel-start)
                    command=tunnel-start
                    ;;
                --tunnel-stop)
                    command=tunnel-stop
                    ;;
                --tunnel-status)
                    command=tunnel-status
                    ;;
                *)
                    usage
                    exit 3
            esac
        done
    else
        usage
        exit 3
    fi

    if [[ ${command:-} ]]; then
        generate ${@}
        wrap-command ${command}
    fi
}
export K8S_ARGV=${@}
# init
check

