#!/bin/bash
# set -o errexit
set -o nounset
set -o pipefail
# The next incarnation will use a git repo pulled into the
# jenkins home

# volumes mapped from git repo

# These scripts assume a directory structure on the target of
# under the jenkins home of 
# .../
#         /.k8s-cfg    # secrets [ until we get k8s secrets + vault ]
#         /bin     # kubectl or other binaries
#         /k8s     # yaml configs
#         /scripts # this script and collections of other helpers

function check
{
    if [[ ! ${dir:-} ]]; then
        echo "dir: variable not set"
        echo "A recipe in the script sourcing this file may work:"
        echo "dir=\$(readlink -f \$(dirname \$(readlink -f \${0}))/..)"
        exit 3
    fi
}

check
mkdir -p ${dir}/.k8s-cfg  ${dir}/.private
chmod 700 ${dir} ${dir}/.k8s-cfg ${dir}/.private

if [[ ! -e ${dir}/.k8s-cfg/options ]]; then
    echo Unconfigured options [.k8s-cfg/options]
    exit 3
fi

. ${dir}/.k8s-cfg/options

if ! [[ -e ${kubeconfig} ]]; then
    printf "k8s username: ";
    read -r username
    printf "${username}'s password: " ;
    read -sr password
    export username=${username}
    export password=${password}
    ${kubectl} config --kubeconfig=${kubeconfig} set-cluster k8s --server=https://${master}:443 \
               --insecure-skip-tls-verify=true
    ${kubectl} config --kubeconfig=${kubeconfig} set-credentials cluster-admin \
               --username=${username} --password=${password}
    ${kubectl} config --kubeconfig=${kubeconfig} set-context k8s --cluster=k8s --user=cluster-admin
    ${kubectl} config --kubeconfig=${kubeconfig} use-context k8s
fi

export kubectl="${kubectl} --kubeconfig=${kubeconfig}"
if [[ -e ${make_yaml_file} ]]; then
    . ${make_yaml_file}
fi
if [[ ! -e ${make_yaml_file} || ! ${make-yaml:-} ]]; then
    echo "Required function make-yaml is not defined"
    echo "It's simplest form could be cat of the yaml file."
    echo "Any function that dumps the yaml on stdout, such as a sed stream edit may also be used."
    exit 3
fi

function start
{
    generate
    ${kubectl} create -f- <<EOF
$(make-yaml)
EOF

}

function stop
{
    ${kubectl} delete -f- <<EOF
$(make-yaml)
EOF
}

function status
{
    ${kubectl} get --output=wide node
    ${kubectl} get --all-namespaces --output=wide rc,pods,svc,ep
}

function generate
{
    rm -f ${yaml}
    if (( debug )); then
        echo "building yaml file ${yaml} for debugging"
        if [[ ! -e ${yaml} ]]; then
            make-yaml > ${yaml}
        fi
        chmod 600 ${yaml}
    fi
}

function git-config
{
    echo
    if [[ -e ${dir}/.git/config ]] && grep remote ${dir}/.git/config ; then

        echo There is an existing git config and repo tag.
        echo Remove the remotes or modify them manually.
        echo
        cat <<MSG
# id comes from .k8s-cfg/config
host ${id}k8s-git-repo
  User                  git
#  Port                  2222
# the name I have the k8s service. . .
#  Hostname             alternate-name
  IdentitiesOnly        yes
  TCPKeepAlive          yes
  IdentityFile          ~/.ssh/id_ed25519
# If connecting from non local work laptop for example . . .
#  ProxyCommand       ssh -XC -A k8s-master-01 -W '%h:%p'
MSG
        echo
        echo "#############################################"
        usage
        exit 3
    fi

    repo=${dir##*/}
    host=${id}k8s-git-repo

    # .ssh/config entry to enable simple access

    # Change port to 22 and comment hostname if using k8s yaml definition.
    # and adding the master [ or host like k8s-master-01 ] to /etc/hosts
    # If accessing remotely via a docker host, maybe mapping -p 2222:22
    # . . .

    # You probably want to have either DNS access or /etc/hosts configured
    # for your host and jump host name. In this example k8s-master-01 acts
    # as the jump host to the DNS enabled k8s cluster

    ssh ${host}<<INIT
mkdir ${repo}.git
cd ${repo}.git
git init --bare
INIT

    cat <<EOF
git remote add ${repo} ${k8srepo}
git push --set-upstream ${repo} master
EOF
    git remote add ${repo} ${k8srepo}
    git push --set-upstream ${repo} master
    git push ${repo} master

    git remote add github ${hubrepo}
    git push --set-upstream github master
}

function push-image
{
    local image=${dir##*/}
    docker save ${image} > ${image}.tar
    for host in k8s-${id}master-01 k8s-${id}node-0{1..2}; do
        ssh ${host} mkdir -p work
        rsync -rlaz --progress --partial ${dir}/${image}.tar ${host}:work/
        ssh -tt ${host} "for file in work/${image}.tar; do echo sudo docker load -i \${file}; sudo docker load -i \${file}; done"
    done
}

function main
{
    if (( $# )) ; then
        # set flags prior to calling any methods
        for arg in ${@}; do
            case ${arg} in
                --debug)
                    debug=1
                    ;;
                --verbose)
                    verbose=1
                    ;;
            esac
        done
        for arg in ${@}; do
            case ${arg} in
                --debug|--verbose) # ignore these, don't generate a usage call
                    ;;
                --push-image)
                    push-image
                    ;;
                --start)
                    start
                    ;;
                --stop)
                    stop
                    ;;
                --status)
                    status
                    ;;
                --git-config)
                    git-config
                    ;;
                *)
                    usage
            esac
        done
    else
        usage
    fi
    exit
}

. ${dir}/.cfg/usage
